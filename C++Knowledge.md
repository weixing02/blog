#### 指针和引用的定义和性质区别

- 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。
- 指针可以初始化为NULL，而引用则必须初始化；
- sizeof(引用)是指的被引用对象的大小；sizeof(指针)是指的指针的大小，通常为4；

#### 堆和栈的区别

- 栈一般是编译器来自动分配和释放的，用来存放参数和局部变量等，随着函数的结束自动被释放，并且栈的内存空间是连续的，向低地址遍历，可申请空间较小，当栈容量不足时栈溢出。
- 堆一般是程序员自己来控制内存的创建和释放的，用来存放全局或者静态变量，类似链表的方式来分配内存，所以可以申请的空间较大，而且比较自由。

#### malloc/free和new/delete的区别

- new自动计算需要分配的空间，而malloc需要手工计算字节数
- new是类型安全的，而malloc不是，比如：
  - int* p = new float[2]; // 编译时指出错误
  - int* p = malloc(2*sizeof(float)); // 编译时无法指出错误
- new operator 由两步构成，分别是 operator new 和 construct（new先调用malloc，再调用构造函数；delete先调用析构函数，再调用free）
- operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力
- new将调用constructor，而malloc不能；delete将调用destructor，而free不能。
- malloc/free要库文件支持，new/delete则不要

#### 面向对象和面向过程的优缺点（C++/C的区别）

- 面向过程
　　- 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 
　　- 缺点：没有面向对象易维护、易复用、易扩展

- 面向对象
　　- 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 
　　- 缺点：性能比面向过程低
  
#### struct和class的区别

- struct也可以实现继承、多态、包含成员函数；
- 最本质的一个区别就是默认的访问控制： 

  - 默认的继承访问权限：struct是public的，class是private的。

#### gcc的编译流程分为四个步骤，分别为：

- 预处理（Pre-Processing）
- 编译（Compiling）
- 汇编（Assembling）
- 链接（Linking）

#### define与const的区别

- 安全性
  - define是没有类型的，编译器只是把常量和名字联系起来，之后做替换，没有安全类型检查，可能会产生错误。
  - const要指定类型，有安全类型检查，存放在静态存储区中，比较安全。

- 内存空间
  - define会在每个用到的地方都拷贝一份进行替换，内存占用比较大。
  - const则只在静态存储区存放一个拷贝，内存占用小。
  
- 编译器处理方式：
  - define在预处理阶段就进行替换；
  - const在编译时确定；
  
- define可以定义一些简单的计算，而const不行；

  >C++中一般使用const而不使用define
  
#### const和static的用法

- https://www.cnblogs.com/jiabei521/p/3335676.html

#### const和static在类中使用的注意事项

- static变量不能在类中初始化，需要在类外进行初始化：```数据类型 类名::变量名 = 值```
- const变量必须在类的初始化列表或者构造函数中初始化，因为变量属于对象，在对象创建的时候才进行初始化；
- const成员函数：const加在尾部，表示成员函数不会修改值，并且也不能调用其他的non-const成员函数；
- const int* p和int* const p：前者表示指针指向的值不能变，后者表示指针本身不能变；
- const对象的动态数组，要进行初始化；

![pic](https://images0.cnblogs.com/blog/460416/201310/06213505-b2b476ac85a34805a6696745b9ff3faa.png)

#### 类的大小计算

- 空类占一个字节
- 类的非虚函数不计算在内，无论是否是静态（即使有析构函数、构造函数、static静态成员函数、普通成员函数）
- 如果类中有虚函数，则需要有一个指针指向虚函数表，函数的开头就是这个指针，占4个字节（无论有多少个虚函数，只需要一个虚函数表，占4字节）
- 如果只有一个int、一个char，则是4+1=5，按4字节对齐就是8字节
- 子类的大小要加上父类的大小，子类和父类共享一个虚函数表

#### int \*p[4]和int (\*p)[4]的区别

- int \*p[4]; 定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。
- int (\*p)[4]; //定义一个数组指针，该指针指向含4个元素的一维数组（数组中每个元素是int型）。

区分int \*p[n]; 和int (\*p)[n]; 就要看运算符的优先级了。
- int \*p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由int\*说明这是一个整型指针数组。
- int (\*p)[n]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。

#### int \*p()与int (\*p)()的区别

- int \*p()是返回指针的函数
- int (\*p)()是指向函数的指针

返回指针的函数：

int \*ａ（int ｘ，int ｙ）;


有若干个学生的成绩（每个学生有４门课程），要求在用户输入学生序号以后，能输出该学生的全部成绩。用指针函数来实现。
- int \*p()是返回指针的函数

#### 重载的作用

- 重载指的是两个同名的参数，拥有不同的参数个数或者参数类型（如果参数类型和个数相同但是返回值类型不同，不算是重载），重载主要是为了方便程序在调用同类型但是参数不同的方法时不用重新命名新的函数，只需要调用相同名字的函数即可，例如：

```
void test()
void test(int x)
void test(int x, int y)
void test(double x)
double test()   // 不算重载
```

#### 运算符的重载

- 单目运算符的重载，如果作为类成员函数进行重载，则不需要形参，因为this指向被操作的对象本身（除了后置++运算符，为了和前置区分开来，添加了int参数），如果是友元函数或者普通函数则有一个形参；

- 双目运算符的重载与单目运算符相似，添加一个形参；

```
class person{
public:
  bool operator<(person& b){  // 作为类成员函数
    return (*this).age < b.age;
  }
}

class person{
public:
  friend bool operator<(person& a, person& b){  // 作为友元函数
    return a.age < b.age;
  }
}

bool operator<(person& a, person& b){
  return a.age < b.age; // 作为普通函数，注意此时age应该为public成员变量，不能直接访问私有变量，所以不推荐使用普通函数重载
}
```
#### 算数运算符 > 关系运算符 > 逻辑运算符

#### union取最长字节为长度

#### 函数指针变量：

>函数指针变量的声明方法为：
返回值类型 ( * 指针变量名) ([形参列表]);
根据定义，
int(*pf)(float);
int (*p)(float)=&f1;
pf,p都是函数指针变量。
函数地址
C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
函数地址的获取，可以是函数名，也可以在函数名前加取地址符&

#### 并不是所有的操作符都能被重载。除了 . ， .* ， :: ， ? : ， sizeof ， typeid 这几个运算符不能被重载，其他运算符都能被重载。

#### 重写与重载与重定义的区别

- 重载：
  - 重载：函数名相同，参数个数或者参数形式不同，不能根据返回值的不同来判断是重载。
- 重写：
  - 重写出现在基类和子类的继承关系中，子类中将父类中的virtual虚函数进行重写，实现有针对性的功能，但是需要注意的是重写时要保证函数的特征和基类的虚函数是相同的；
  - 被重写的函数不能是static函数，必须有关键字；
  - 重写需要保证函数参数返回类型相容、参数个数、函数名相同；
  - 访问修饰符可以不同，可以由public转变为protected或者private；
- 重定义（两种，也存在在基类和派生类中）：
  - 如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。
  - 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。
  
 #### 虚函数的实现
 
 - https://www.cnblogs.com/malecrab/p/5572730.html
 
 #### 自由存储区和堆的区别
 
- 自由存储是C++中通过new与delete动态分配和释放对象的抽象概念，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。

- new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。

- 堆与自由存储区还是有区别的，它们并非等价。

#### C++内存管理机制

- C++中共有5个存储区域分别为：堆、栈、自由存储区、静态/全局存储区、常量存储区
  - 堆：是操作系统的术语，用于程序内存的动态分配，C/C++中用malloc和free来分配和释放内存；
  - 栈：在执行函数时，函数内的局部变量都是在栈上创建的，函数执行结束时被自动释放，效率很高，但是容量有限；
  - 自由存储区：C++中用new和delete申请和释放的区域，是C++中的一个抽象概念；
  - 静态/全局存储区：编译时就已经确定分配好的，在程序运行期间都存在；
  - 常量存储区：const等不可修改的常量数据存储区；

#### 析构函数为什么通常定义为虚函数

  - 因为如果析构函数不是虚函数，那么假设
  ```
  class a{
    ~a(){};
  }
  
  class b : public a{
    ~b(){};
  }
  int main(){
    a* aptr = new b();
    delete aptr;  // 只调用父类a的析构函数，而b对象不会被释放
  }
  ```
  如果定义为虚函数，则会根据对象类型，先调用派生类的析构函数、再调用基类的析构函数，才能完全释放；
  
#### 面向对象的三大特性，举例

- 封装：就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。例如把学校里的学生封装成一个类，类中有成绩、姓名、年龄等信息，将这些信息设置为private，那么就只能通过间接的方式来访问或者修改这些私密数据。

#### 调用拷贝构造函数的三种情况：

- 利用一个已经生成的对象初始化另一个对象时；
- 将对象作为函数参数值传递；
- 函数的返回值为对象；

#### 结构体、类的对齐方式：

1. 结构体的每个成员相对于结构体首地址的偏移量都是成员大小的整数倍。

2. 结构体的总大小为最结构体最宽基本类型成员的整数倍。　

3. 结构体的首地址能够被最宽基本类型成员所整除。

- 原因在于CPU内部使用内存时是按块来使用的，例如2字节、4四节，如果不进行对齐就会造成效率低下的问题，例如一个char类型和int类型如果连续存储，不进行对齐，那么他们的分布情况是0|0000，地址是0x00-0x04，那么如果CPU要取出int，则CPU要先取出0x00-0x03，再取出0x04-0x07，将前后剔除，再合并数据，造成了时间浪费；

#### 什么是内存泄漏，如何预防和解决：

- 内存泄漏是指动态分配的内存在使用后未回收，直到程序结束后才释放，这导致这部分分配的内存空间无法被使用，如果存在很多这样的情况，最终会导致内存被榨干，内存溢出；

- 例如开辟了一块动态内存，用指针指向它，但是把指针置为NULL，这时候没有指针指向这块内存，也就没办法使用这块内存了；

- 如何预防：尽量不自己开辟动态内存和释放动态内存，例如使用STL的vector而尽量不使用array；使用智能指针shared_ptr，当计数为0的时候会自动删除被指向的对象；在基类中一定要将析构函数设置为virtual

#### 模板的使用

- 使用模板是为了实现泛型，可以减轻编程的工作量，增强函数的重用性。
- 例如将两个变量交换的函数swap；
- 如果不是用模板的话我们需要针对不同的类型写很多个功能相同的函数，例如int、char等等
- 而使用模板的话则只用使用一个函数就足够了
```
template<class T>
void swap(T a, T b);
```
#### 成员初始化列表的使用，性能：

- 成员初始化列表写在构造函数中，通过冒号和成员变量+括号的方式来初始化成员变量。
- 初始化列表在初始化基本数据类型如float、char、int的时候和普通的构造函数体内初始化没有什么差别，但是如果有类类型的成员函数需要初始化，那么使用初始化列表会有性能提升；原因在于如果使用普通的方法进行初始化，则会多调用一次类的默认构造函数，开销是很大的。
- 除了上述的原因，有以下两种情况也是必须使用初始化列表来进行初始化成员的：
  - const和引用类型的成员，由于const只能初始化不能赋值，引用类型在声明时就需要初始化，所以只能用初始化列表来初始化；
  - 如果类类型的成员的类中没有提供默认的构造函数，那么就必须使用成员初始化列表，否则就会编译失败；
  
#### C++四种强制类型转换

- static_cast提供了编译期间的静态类型检测，例如char\* 不能直接转换为int\*，和C语言中的隐式转换效果差不多；
  - 基础类型之间的转换
  - 基类派生类之间的转换（upcast没有问题，但是downcast可能存在风险）
  - 任意类型与void的转换，或者任意类型的指针与void\*指针的转换

- dynamic_cast提供了运行时的类型检查
